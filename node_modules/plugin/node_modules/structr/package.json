{
  "name": "structr",
  "description": "Clean OO structure for Javascript.",
  "version": "0.2.3",
  "author": {
    "name": "Craig Condon"
  },
  "repository": {
    "type": "git",
    "url": "http://github.com/spiceapps/Structr.git"
  },
  "main": "./lib/index.js",
  "readme": "Structr -  Structure for Javascript            \n======================================== \n\nStructr is a framework with the following goals:\n                                               \n* Lightweight.\n# Fast.\n* Provide as few new concepts as possible coming from OOP.\n* Easy to learn.\n* Help develop re-useable, clean, and consistent code.              \n* Reduce the amount of reduntant/boilerplate code.  \n\n\n### Supported Operators:        \n                                             \n* _super                                     \n* inheritance      \n* overloading methods\n* Implicit / Explicit getters & setters\n* Override, and Static  \n* abstract methods\n* add your own custom operators (mixins)\n\n\n### Third-party mixins\n\n* [asyngleton](/crcn/asyngleton.js) - asynchronous singletons\n* [step](/crcn/structr-step) \n                           \n\n\n### Installation\n\nNode.js: \n\n\tnpm install structr\n\t\t   \n\t\t\n### .structr([...parents], classObject)\n\n\n```javascript\n\nvar EventEmitter = require(\"events\").EventEmitter,\nstructr          = require(\"structr\");\n \n/**\n * create a mouse class which extends the node.js event emitter\n */\n\nvar Mouse = structr(EventEmitter, {  \n\n\t/**\n\t */\n\n\t\"__construct\": function() {\n\t\tthis._super();\n\n\t\t//initial coords\n\t\tthis.move(0, 0);\n\t},\n\n\t/**\n\t * moves the mouse\n\t */\n\n\t\"move\": function(x, y) {\n\t\tthis.position({ x: x, y: y});\n\t},\n\n\t/**\n\t * second version of move incase an object is provided\n\t */\n\n\t\"second move\": function(position) {\n\t\tthis.position(position);\n\t},\n\n\t/**\n\t * getter / setter for the position\n\t */\n\n\t\"explicit position\": {\n\t\t\"get\": function() {\n\t\t\treturn this._position;\n\t\t},\n\t\t\"set\": function(value) {\n\t\t\tthis._position = value;\n\t\t\tthis.emit(\"move\");\n\t\t}\n\t} \n});                      \n\nvar mouse = new Mouse();\n\n//listen for when the mouse has moved\nmouse.on(\"move\", function() {\n\tconsole.log(\"mouse moved!\");\n})\n\n//move 100 px left, and 100 px from the top\nmouse.move(100, 100);\n\n```\n\n\n### Class.extend(target, [...mixins]);\n\nExtends a class\n\n\n```javascript\n\nvar fs  = require(\"fs\"),\nstructr = require(\"structr\"),\nmkdirp  = require(\"mkdirp\"),\npath    = require(\"path\");\n\n//mixin the singleton plugin\nstructr.mixin(require(\"asyngleton\"));\n\n/**\n * base cache interface\n */\n\nvar AbstractCache = structr({\n\t\n\t/**\n\t * returns a cached value\n\t */\n\n\t\"abstract get\": function(key, onGet) { },\n\n\t/**\n\t * sets a cached value\n\t */\n\n\t\"abstract set\": function(key, value, onSet) { }\n});\n\n/**\n * memory cache\n */\n\nvar MemoryCache = AbstractCache.extend({\n\t\n\t/**\n\t */\n\n\t\"__construct\": function() {\n\t\tthis._collection = {};\n\t},\n\n\t/**\n\t */\n\n\t\"get\": function(key, onGet) {\n\t\tonGet(null, this._collection[key]);\n\t},\n\n\t/**\n\t */\n\n\t\"set\": function(key, value, onSet) {\n\t\tthis._collection[key] = value;\n\t\tif(onSet) onSet(null, value);\n\t}\n});\n\n\n/**\n */\n\nvar FsCache = MemoryCache.extend({\n\t\t\n\t/**\n\t */\n\n\t\"override __construct\": function(path) {\n\t\tthis._path = path;\n\t\tthis._super();\n\t},\n\n\t/**\n\t */\n\n\t\"override set\": function() {\n\t\tthis._super.apply(this, arguments);\n\t\tthis._save();\n\t},\n\n\t/**\n\t */\n\n\t\"override get\": function(key, onKey) {\n\t\tvar _super = this._super;\n\n\t\t//load the fs cache before getting the value - this only happens ONCE \n\t\t//since _load is an asynchronous singleton.\n\t\tthis._load(function() {\n\t\t\t_super(key, onKey);\n\t\t});\n\t},\n\n\n\t/**\n\t * saves the collection to disc\n\t */\n\n\t\"_save\": function() {\n\t\tif(this._saving) return;\n\t\tthis._saving = true;\n\n\t\tvar self = this;\n\n\t\t//make the directory incase it doesn't exist. \n\t\tthis._mkdir(path.dirname(this._path), function() {\n\n\t\t\t//write the json file, with the json content\n\t\t\tfs.writeFile(self._path, JSON.parse(self._collection), function(err result) {\n\n\t\t\t\t//give some time before unlocking the save method. \n\t\t\t\t//We don't want to hit fs.write on each set\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tself._saving = false;\n\t\t\t\t}, 2000);\n\t\t\t});\n\t\t});\n\t},\n\n\t/**\n\t * loads the fs cache into memory\n\t */\n\n\t\"singleton _load\": function(onLoad) {\n\t\ttry {\n\t\t\tthis._collection = require(this._path);\n\t\t} catch(e) {\n\t\t\t//do nothing - the file doesn't exist\n\t\t}\n\t\tonLoad();\n\t},\n\n\t/**\n\t * makes the fs cache directory incase it's nested. Only happens ONCE on save.\n\t */\n\n\t\"singleton _mkdir\": function(onMkdir) {\n\t\tmkdirp(path.dirname(this._path), onMkdir);\n\t}\n});\n\n\nvar cache = new FsCache(__dirname + \"/test.json\");\n\n\ncache.get(\"name\", function(err, name) {\n\n\tif(name) {\n\t\treturn console.log(\"hello %s!\", name);\n\t}\n\n\tcache.set(\"name\", \"craig\", function() {\n\t\tconsole.log(\"saved!\");\n\t});\n});\n\n```\n\n### Modifiers    \n                      \n### Overriding Methods\n\nMethods overridden have access to the _super property.\n\n```javascript\n\n\"override __construct\": function ()\n{\n\tthis._super();\n}\n\n```\n\n### Overwriting Methods\n   \nFaster if you don't plan on using _super.\n\n\n```javascript\n\n\"__construct\": function ()\n{\n\t//cannot access _super __construct\n}\n\n```\n\t\n\t\n### Overloading Methods (Experimental)\n\nOverloading methods allows you to write methods which are mapped out depending on the number of parameters used. You must provide your own identifier (it could be anything) for each overloaded method, otherwise you'll simply be overwriting methods. For this example, I separate methods based on their order, e.g. `one`, `two`, `three`, etc.\n\n\n```javascript\n\nvar Person = Structr({\n\n\t\"sayHello\": function (name, callback)\n\t{\n\t\tthis._name = name;\n\t\tthis.sayHello(callback);\n\t},\n\n\t\"second sayHello\": function (callback)\n\t{\n\t\tcallback(this.sayHello());\n\t},\n\n\t\"third sayHello\": function ()\n\t{\n\t\treturn 'Hello ' + this._name;\n\t}\n});\n\nvar SubPerson = Person.extend({\n\n\t\"override sayHello\": function (callback)\n\t{\n\t\tcallback(this.sayHello() + \" Do you like italian food?\");\n\t},\n\n\t\"override second sayHello\": function ()\n\t{\n\t\treturn \"Hello \" + this._name + \", how are you doing today?\";\n\t}\n});\n\n\nvar p = new SubPerson();\np.sayHello(\"Craig\", function(message)\n{\n\talert(message); //Hello Craig. how are you doing today? Do you like italian food?\n});\n\n```\n\n### Static Keyword \n\nProperties, and methods set to the class versus objects instantiated.\n\n\n```javascript\n\nvar Singleton = Structr({\n\t\n\t\"static getInstance\": function ()\n\t{\n\t\treturn this._instance || (this._instance = new Singleton());\n\t}\n});\n\nvar test1 = Singleton.getInstance();\nvar test2 = Singleton.getInstance();\ntest2.name = 'Craig';\n\nconsole.log(test1.name); //Craig\n\n```\n\n### Getters & Setters   \n\nBoth Implicit / Explicit methods are supported, however implicit getters & setters aren't supported in all browsers. Use implicit get/set if you're doing any development under a specific platform such as Node.js, or Appcelerator Titanium.\n\n\n\n```javascript\n\nvar GSTestClass = Structr({\n\n\t\"explicit explicitValue\": {\n\t\t\"get\": function ()\n\t\t{\n\t\t\treturn this._name;\n\t\t},\n\t\t\"set\": function (value)\n\t\t{\n\t\t\tthis._name = value;\n\t\t}\n\t},\n\t\n\t\"implicit implicitValue\": {\n\t\t\"get\": function ()\n\t\t{\n\t\t\treturn this._name;\n\t\t},\n\t\t\"set\": function (value)\n\t\t{\n\t\t\tthis._name = value;\n\t\t}\n\t},\n\t\n\t\"explicit explicitValue2\":true\n});\n\n\nvar test = new GSTestClass();\ntest.explicitValue('Craig'); \nconsole.log(test.explicitValue());\n\ntest.implicitValue = 'Tim';\nconsole.log(test.implicitValue);//Tim\nconsole.log(test.explicitValue());//Tim\n\ntest.explicitValue2('hello world');\nconsole.log(test.explicitValue2());//hello world\n\t\n```\n\nMetadata \n--------\n\nCustom modifiers are considered metadata. Use them to identify how specific methods should be handled.\n\n\n```javascript\n\n\nvar MetadataTestClass = Structr({\n\t\n\t\"myCustomMetadata test\": function ()\n\t{\n\t\treturn \"Hello Test\";\n\t}\n}));\n\n\nconsole.log(MetadataTestClass.prototype.test.myCustomMetadata); //true\n\n```\n\t\n\t\n###Bindable Metadata\n\nTo add. Makes a property bindable for change. Psuedocode:\n\n\n```javascript\n\nvar Person = Structr({\n\t\n\t\"__construct\": function(name)\n\t{\n\t\tthis.name(name);\n\t\t\n\t\tBindable.apply(this);\n\t},\n\t\n\t\"bindable explicit name\": 1\n});\n\n\nvar person1 = new Person(\"craig\");\n\n//listen for any change to name\nperson1.name.subscribe(function(newName)\n{\n\talert('Name changed to '+newName);\n});\n\n//on change the subscribers will be triggered\nperson1.name(\"Craig\");\n\n```\n\t\n###Setting Metadata\n\nTo add. Easy way to store settings on the user's computer. Psuedocode:\n\n\n```javascript\n\nvar User = Structr({\n\n\t\"__construct\": function ()\n\t{\n\t\tSettingManager.apply(this);\n\t},\n\t\n\t\"login\": function ()\n\t{\n\t\t\n\t\t//set the account info which will be saved as a cookie\n\t\tthis.accountInfo({ name: \"Craig\", last: \"Condon\", token: \"XXXXXXXXXX\" })\n\t},\n\t\n\t\"setting explicit accountInfo\": 1\n});\n\n\nvar u = new User();\n\n//this gets passed once\nif(!u.accountInfo)\n{\n\tu.login();\n}\nelse\n{\n\t//pulled from local computer\n\talert(u.accountInfo.name);\n}\n\n```\n\t\n\t\nTips:\n----\n\n\t\n* Wrap methods / properties in single, or double quotes. \n* Avoid the over-use of override, or overloaded methods.\n* Only use Structr where you would create prototyped classes.\n\n\nTo Do:\n------\n\n- change _super(...) to _super({ method: [args]  }), or _super('method').call(...);\n\n\t\n\n\n",
  "readmeFilename": "README.md",
  "_id": "structr@0.2.3",
  "_from": "structr@0.2.x"
}
