{
  "author": {
    "name": "Craig Condon"
  },
  "name": "plugin",
  "description": "Plugin library",
  "version": "0.2.5",
  "repository": {
    "type": "git",
    "url": "git://github.com/crcn/plugin.js.git"
  },
  "dependencies": {
    "dref": "0.0.x",
    "underscore": "1.4.x",
    "async": "0.1.x",
    "outcome": "0.0.x",
    "sift": "0.0.x",
    "structr": "0.2.x",
    "resolve": "0.2.x"
  },
  "devDependencies": {},
  "main": "./lib/node.js",
  "browserify": "./lib/web.js",
  "readme": "### Plugin Library for node.js\n\n### Motivation\n\n- Modularity - encourages code-reuse, abstraction, and encapsulation\n- Easily drop plugins in and out without breaking your program\n- Maintainability\n- Flexibility over dependencies\n- Asyncronously load remote plugins via [dnode](/substack/dnode) (*soon* - [now.js](/flotype/now), [beanpoll](beanpole)). \n- *soon* double as online async module loader (similar to [head](https://github.com/headjs/headjs)).\n\n## Basic Usage\n\nA simple use case with express:\n\n```javascript\n\nvar plugin = require('plugin').loader(),\nserver = require('express').createServer();\n\nplugin.options(server, true).\nrequire(\"path/to/plugins/dir\");\n\nserver.listen(8080);\n\n```\n\nIn your `hello world` plugin:\n\n```javascript\n\nexports.plugin = function(server) {\n\t\n\tserver.get('/', function(req, res) {\n\t\t\n\t\tres.send(\"Hello World!\");\n\t});\n}\n\n```\n\n## Plugins\n\n- [plugin.dnode](/crcn/plugin.dnode) - dnode plugin\n\n\n## Plugin API\n\n### plugin.require(path)\n\nincludes target dependencies\n\n```javascript\nplugins.require('path/to/plugin.js').      // require one plugin\nrequire('path/to/plugins/dir').          // require all plugins in directory\nrequire('path/to/plugins/**/*.plugin.js'). // find plugins, and load them\nrequire('plugin1.js','plugin2.js','plugin3.js'). //multiple plugin args\nrequire('./config.json').load(); //load plugins in configuration file { plugins: ['my/plugin.js','...'] }\n```\n\n### plugin.paths(path)\n\nadds a path to scan when requiring plugins. Similar to the old `require.paths.unshift`\n\n```javascript\nplugin.paths('/path/to/plugins').require('my-plugin');\n\nconsole.log(plugin.paths());// ['/path/to/plugins','/path/to/node_modules','...'];\n```\n\n### plugin.params(params)\n\nparams specific to plugin - like constructor parameters\n\nbootstrap.js:\n\n```javascript\nplugin.params({\n\t'server': {\n\t\t'port': 8080\n\t}\n}).\n\n//or\nparams('server', { port: 8080 }).\nrequire('server');\n```\n\napi.server/index.js:\n\n```javascript\nexports.plugin = function(ops, params) {\n\tconsole.log(params.port); //8080\t\n}\n```\n\n\n### plugin.options(ops)\n\nAdds / returns options which are passed in the first parameter for each plugin.\n\nbootstrap.js:\n\n```javascript\nplugin.options({ message: 'hello world!' }).require('hello.plugin.js');\n```\n\nhello.plugin.js:\n\n```javascript\nexports.plugin = function(ops) {\n\tconsole.log(ops.message); //hello world!\n}\n```\n\n### plugin.onLoad(pluginSearch, ret, callback)\n\nListens for when a plugin is ready - useful especially if a dnode server resets\n\n```javascript\n\nplugin.onLoad('my.plugin', function() {\n\t\n\tconsole.log(\"ready!\");\n}).require('my.plugin');\n```\n\n### plugin.local plugin.remote\n\nremote/local collections. Same api as plugin (emit, plugin, plugins)\n\n### plugin.emit(type, data)\n\nemits a method against all loaded plugins. If the method doesn't exist, it'll be ignored.\n\nbootstrap.js:\n\n```javascript\nplugin.loader().require('api.server').load().emit('doStuff');\n```\n\napi.server/index.js:\n\n```javascript\nexports.plugin = function() {\n\t\n\treturn {\n\t\tdoStuff: function() {\n\t\t\tconsole.log(\"PREPARE\");\t\n\t\t},\n\t\tinit: function() {\n\t\t\tconsole.log(\"INIT\");\n\t\t}\n\t};\n}\n```\n\n### plugin.load()\n\nLoads the plugins, and initializes them.\n\n### plugin.next(callback)\n\nQueue function called after loading in all modules\n\n### plugin.exports\n\nAll the invokable methods against modules\n\n\n\n\n### plugin.plugins(search)\n\nReturns *multiple* plugins based on the search criteria.\n\n```\n\nvar loader = plugin.loader();\n\nloader.require('oauth.part.twitter','oauth.part.facebook','oauth.core').\nload(function() {\n\tloader.plugins(/^oauth.part.\\w+$/).forEach(function(service) {\n\t\n\t\t//do stuff with the oauth plugins\n\n\t});\n});\n```\n\n\n### plugin.plugin(search)\n\nReturns a *single* based on the search criteria given.\n\n\n### plugin.loaders\n\nLoads plugins passed into `plugin.require()`.\n\n```javascript\n//dnode plugin\nplugin.loaders.push({\n\ttest: function(path) {\n\t\treturn !!path.match(/dnode+\\w+:\\/\\//); //dnode+https://my-dnode-server.com\n\t},\n\tload: function(path, callback) {\n\t\t//load dnode module here\n\t}\n});\n```\n\n### plugin.factory(fn)\n\nPlugin factory function\n\nplugin.factory(function(module, options, params) {\n\treturn module(options, params); //instead of exports.plugin = function(){}, it would be module.exports = function(options, params)\n});\n\n### plugin.newPlugin\n\nPlugin factory for plugin. Setting this method will change the way modules are loaded in.\n\n```javascript\n\n\nplugin.newPlugin = function(module, options, params) {\t\n\treturn module(options, params); //instead of exports.plugin = function(){}, it would be module.exports = function(options, params)\n};\n\n```\n\n\n## Plugins API\n\n\n### exports.require\n\nDependencies for the given plugin. This is checked once `plugin.call`, or `plugin.load` is invoked. An exception is thrown if there are any missing dependencies.\n\n```javascript\n\nexports.require = ['api.services.photos.*','another-plugin']; //requires any photo services. E.g: api.services.photos.facebook, api.services.photos.flickr\n\nexports.require = [/api\\.\\w+/]; //regexp test\n\nexports.require = function(name) { //function test\n\treturn name.indexOf('api.services.photos') > -1\n};\n\n\n```\n\nYou can also load in any given plugin via `exports.require`:\n\n```javascript\n\nexports.require = 'my-plugin';\n\n\nexports.plugin = function() {\n\t\n\tvar plugin = this;\n\n\treturn {\n\t\tinit: function() {\n\t\t\t\n\t\t\tplugin.plugin('my-plugin').doStuff();//return a single instance\n\t\t\tplugin.plugins('my-plugin').forEach(funtion(plugin) {//return multiple instances\n\t\t\t\tplugin.doStuff();\n\t\t\t});\n\t\t}\n\t}\n}\n```\n\n### exports.name\n\nOptional name for the plugin. The default value is name provided when requiring the plugin.\n\n\n### Plugin exports.plugin(options, params, plugin)\n\nCalled when the plugin is loaded. \n\n- `options` - options which are passed to the plugin, along with every other plugin.\n- `params` - parameters which are specific to the loaded plugin.\n- `plugin` - the plugin loader. Also accessible via `this`.\n- return type can be `void`, or an `object`.\n\n\n\n\n\n\n\n \n\n",
  "readmeFilename": "README-old.md",
  "_id": "plugin@0.2.5",
  "_from": "plugin"
}
